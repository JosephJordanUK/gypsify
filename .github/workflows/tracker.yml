name: Publish tracking artifacts to tracker/dev

on:
  push:
    branches: [dev]
    paths-ignore:
      - 'prompt/latest-sha.txt'
      - 'prompt/manifest.json'
      - 'prompt/changed-in-latest.json'
      - 'prompt/latest-bundle.json'
      - 'prompt/snapshots/**'
      - '.github/workflows/**'
  pull_request:
    branches: [dev]

concurrency:
  group: tracker-dev
  cancel-in-progress: true

permissions:
  contents: write

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout source (dev)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Resolve SHAs from event
        id: shas
        run: |
          set -e
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            NEW="${{ github.event.pull_request.head.sha }}"
            OLD="${{ github.event.pull_request.base.sha }}"
            git fetch --no-tags origin "$OLD" "$NEW" || true
          else
            NEW="${{ github.sha }}"
            if git rev-parse -q --verify "${NEW}^1" >/dev/null; then
              OLD=$(git rev-parse "${NEW}^1")
            elif git cat-file -e "${{ github.event.before }}"^{commit} 2>/dev/null; then
              OLD="${{ github.event.before }}"
            else
              OLD=$(git rev-parse "${NEW}^")
            fi
          fi
          echo "NEW_SHA=$NEW" >> "$GITHUB_OUTPUT"
          echo "OLD_SHA=$OLD" >> "$GITHUB_OUTPUT"
          echo "Resolved NEW=$NEW"
          echo "Resolved OLD=$OLD"

      - name: Fetch tracker branch
        run: |
          git fetch origin tracker/dev || true

      - name: Prepare tracker workspace (switch to tracker/dev)
        run: |
          if git show-ref --verify --quiet refs/remotes/origin/tracker/dev; then
            git checkout -B tracker/dev origin/tracker/dev
          else
            git checkout --orphan tracker/dev
            rm -rf .
            mkdir -p prompt
            git add prompt
            git -c "user.name=github-actions[bot]" -c "user.email=41898282+github-actions[bot]@users.noreply.github.com" commit -m "chore(tracker): init branch"
          fi
          # Clean everything except .git and prompt/
          find . -mindepth 1 -maxdepth 1 ! -name ".git" ! -name "prompt" -exec rm -rf {} +
          mkdir -p prompt bundle

      - name: Copy dependency snapshots from dev
        run: |
          mkdir -p prompt/deps
          git show origin/dev:package.json > prompt/deps/package.json
          git show origin/dev:yarn.lock > prompt/deps/yarn.lock || true

      - name: Mirror prompt sources from dev
        run: |
          mkdir -p prompt
          for f in \
            prompt/MasterPrompt.md \
            prompt/checklist.md \
            prompt/mini-manifest.yml \
            prompt/project-overview.txt
          do
            git show origin/dev:"$f" > "$f" || true
          done

      - name: Build manifest.json from dev tree
        run: |
          jq -n '[]' > prompt/manifest.json
          git ls-files --with-tree=origin/dev \
            | grep -Ev '^(node_modules/|ios/|android/|tests/|docs/|\.git/|\.github/workflows/|prompt/)' \
            | while read -r f; do
                BYTES=$(git cat-file -s "origin/dev:$f" || echo 0)
                if [ "$BYTES" != "0" ]; then
                  SHA256=$(git show "origin/dev:$f" | sha256sum | cut -d" " -f1)
                  jq --arg path "$f" --argjson bytes "$BYTES" --arg sha "$SHA256" \
                     '. + [{"path":$path,"bytes":$bytes,"sha256":$sha}]' \
                     prompt/manifest.json > prompt/manifest.tmp && mv prompt/manifest.tmp prompt/manifest.json
                fi
              done

      - name: Build changed-in-latest.json (diff + recent fallback, 5â€“10 files)
        env:
          MIN: '5'
          MAX: '10'
        run: |
          set -euo pipefail
          OLD="${{ steps.shas.outputs.OLD_SHA }}"
          NEW="${{ steps.shas.outputs.NEW_SHA }}"
          IGNORE='^(node_modules/|ios/|android/|tests/|docs/|\.git/|\.github/workflows/|prompt/|assets/)'

          list_unique() { awk 'NF && !seen[$0]++'; }
          exists_in_new() { git cat-file -e "$NEW:$1" 2>/dev/null; }
          count() { printf '%s\n' "$1" | list_unique | grep -c . || true; }

          DIFF=$(git diff --name-only "$OLD" "$NEW" 2>/dev/null | grep -Ev "$IGNORE" || true)
          CANDIDATES="$DIFF"

          if [ "$(count "$CANDIDATES")" -lt "$MIN" ]; then
            LASTDAY=$(git log --since="24 hours ago" --name-only --pretty="" origin/dev | grep -Ev "$IGNORE" || true)
            CANDIDATES=$(printf '%s\n%s\n' "$CANDIDATES" "$LASTDAY")
          fi
          if [ "$(count "$CANDIDATES")" -lt "$MIN" ]; then
            LAST50=$(git log -n 50 --name-only --pretty="" origin/dev | grep -Ev "$IGNORE" || true)
            CANDIDATES=$(printf '%s\n%s\n' "$CANDIDATES" "$LAST50")
          fi

          FINAL=$(printf '%s\n' "$CANDIDATES" \
            | list_unique \
            | while IFS= read -r f; do exists_in_new "$f" && printf '%s\n' "$f"; done \
            | head -n "$MAX")

          printf '%s\n' "$FINAL" | jq -R -s 'split("\n") | map(select(length>0))' > prompt/changed-in-latest.json
          echo "changed-in-latest.json:"; cat prompt/changed-in-latest.json

      - name: Write latest-sha.txt
        run: |
          echo "${{ steps.shas.outputs.NEW_SHA }}" > prompt/latest-sha.txt

      - name: Write snapshots of changed files from dev
        run: |
          set -e
          SHA="${{ steps.shas.outputs.NEW_SHA }}"
          mkdir -p "prompt/snapshots/${SHA}"
          CHANGED=$(jq -r '.[]' prompt/changed-in-latest.json)
          for f in $CHANGED; do
            mkdir -p "prompt/snapshots/${SHA}/$(dirname "$f")"
            git show "${SHA}:${f}" > "prompt/snapshots/${SHA}/${f}" || true
          done

      - name: Write per-file JSONs and index
        run: |
          set -e
          SHA="${{ steps.shas.outputs.NEW_SHA }}"
          ROOT_DIR="bundle/by-path"
          INDEX="bundle/index.json"

          mkdir -p "$ROOT_DIR"
          echo '{"sha":"'"$SHA"'","files":[]}' > "$INDEX"

          b64() { printf '%s' "$1" | base64 -w0; }

          jq -r '.[].path' prompt/manifest.json | while read -r f; do
            if ! git show "origin/dev:$f" >/dev/null 2>&1; then continue; fi
            size=$(git cat-file -s "origin/dev:$f" || echo 0)
            if [ "$size" -gt $((1024*1024)) ]; then continue; fi

            CONTENT_B64=$(git show "origin/dev:$f" | base64 -w0)
            OUT="$ROOT_DIR/$(b64 "$f").json"
            printf '{"path":"%s","encoding":"base64","content":"%s"}' "$f" "$CONTENT_B64" > "$OUT"

            tmp=$(mktemp)
            jq --arg path "$f" --arg href "bundle/by-path/$(b64 "$f").json" \
               '.files += [{"path":$path,"href":$href}]' "$INDEX" > "$tmp" && mv "$tmp" "$INDEX"
          done

      - name: Build multi-part all-files bundles (10,000 characters max each, skip >8,000 char files)
        run: |
          set -e
          SHA="${{ steps.shas.outputs.NEW_SHA }}"
          MANIFEST="prompt/manifest.json"
          BUNDLE_DIR="bundle/multipart"
          mkdir -p "$BUNDLE_DIR"

          MAX_CHARS=75000    # 10k chars per part
          MAX_FILE=50000      # skip any file >8k chars

          PART=0
          CURRENT_CHARS=0
          OUT_FILE="$BUNDLE_DIR/part-$PART.json"
          echo '{"sha":"'"$SHA"'","files":[]}' > "$OUT_FILE"

          jq -r '.[].path' "$MANIFEST" | while read -r f; do
            if git show "origin/dev:$f" >/dev/null 2>&1; then
              CONTENT_B64=$(git show "origin/dev:$f" | base64 -w0)
              ENTRY=$(mktemp)
              printf '{"path":"%s","content":"%s"}' "$f" "$CONTENT_B64" > "$ENTRY"
              CHARS=$(wc -m < "$ENTRY")

              if [ "$CHARS" -gt $MAX_FILE ]; then
                echo "Skipping $f (size $CHARS chars > $MAX_FILE limit)"
                continue
              fi

              if [ $((CURRENT_CHARS + CHARS)) -gt $MAX_CHARS ]; then
                PART=$((PART+1))
                OUT_FILE="$BUNDLE_DIR/part-$PART.json"
                echo '{"sha":"'"$SHA"'","files":[]}' > "$OUT_FILE"
                CURRENT_CHARS=0
              fi

              tmp=$(mktemp)
              jq --slurpfile e "$ENTRY" '.files += $e' "$OUT_FILE" > "$tmp" && mv "$tmp" "$OUT_FILE"
              CURRENT_CHARS=$((CURRENT_CHARS + CHARS))
            fi
          done

      - name: Remove legacy latest-bundle.json if present
        run: |
          git rm -f prompt/latest-bundle.json || true

      - name: Configure SSH for deploy key
        env:
          DEPLOY_KEY: ${{ secrets.TRACKER_DEPLOY_KEY }}
        run: |
          install -d -m 700 ~/.ssh
          echo "$DEPLOY_KEY" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan github.com >> ~/.ssh/known_hosts
          git config user.name "tracker-bot"
          git config user.email "tracker-bot@users.noreply.github.com"

      - name: Copy firebase.json from dev
        run: |
          git show origin/dev:firebase.json > firebase.json
          git add firebase.json

      - name: Commit and push artifacts to tracker/dev
        run: |
          git add prompt/latest-sha.txt prompt/manifest.json prompt/changed-in-latest.json bundle prompt/snapshots prompt/deps firebase.json
          if ! git diff --cached --quiet; then
            git commit -m "chore(tracker): publish artifacts for ${{ steps.shas.outputs.NEW_SHA }} [skip ci]"
            git push git@github.com:${{ github.repository }}.git HEAD:tracker/dev
          else
            echo "No changes to publish."
          fi

      - name: Prepare Firebase hosting folder
        run: |
          rm -rf hosting
          mkdir -p hosting
          cp -r bundle hosting/
          rsync -av --exclude='snapshots/' prompt/ hosting/prompt/
          if [ -f firebase.json ]; then cp firebase.json hosting/; fi

          find hosting -type f \( -name "*.json" -o -name "*.md" \) | while read f; do
            mv "$f" "$f.txt"
          done

      - name: Generate index.html of hosted files
        run: |
          {
            echo "<html><body><h1>Gypsify Tracker Files</h1><ul>"
            find hosting -type f | while read f; do
              REL="${f#hosting/}"
              echo "<li><a href='/$REL'>$REL</a></li>"
            done
            echo "</ul></body></html>"
          } > hosting/index.html

      - name: List hosted URLs
        run: |
          echo "Hosted files available at:"
          find hosting -type f | while read f; do
            URL="https://gypsify-35447.web.app/${f#hosting/}"
            echo "$URL"
          done

      - name: Deploy to Firebase Hosting
        uses: FirebaseExtended/action-hosting-deploy@v0
        with:
          repoToken: '${{ secrets.GITHUB_TOKEN }}'
          firebaseServiceAccount: '${{ secrets.FIREBASE_SERVICE_ACCOUNT }}'
          projectId: gypsify-35447
          entryPoint: ./
          channelId: live
